{"version":3,"file":"normalized-reducer.cjs.production.min.js","sources":["../src/enums.ts","../src/util.ts","../src/validator.ts","../src/schema.ts","../src/selectors.ts","../src/messages.ts","../src/actions.ts","../src/derivator.ts","../src/index.ts","../src/reducer.ts","../src/normalizr.ts"],"sourcesContent":["export enum Cardinalities {\n  ONE = 'one',\n  MANY = 'many',\n}\n\nexport enum UpdateActionMethod {\n  PUT = 'put',\n  PATCH = 'patch',\n}\n","export const noop = () => {};\n\nexport const arrayPut = <T>(item: T, array?: T[], index?: number): T[] => {\n  if (!array) {\n    return [item];\n  }\n\n  const newArray = [...array];\n  // must check against undefined because index might === 0\n  index === undefined ? newArray.push(item) : newArray.splice(index, 0, item);\n  return newArray;\n};\n\nexport function arrayMove<T>(arr: T[], fromIndex: number, toIndex: number): T[] {\n  if (fromIndex < 0 || toIndex < 0) {\n    return arr;\n  }\n\n  // if the fromIndex is greater than the highest index, then set it as the highest index\n  fromIndex = fromIndex > arr.length - 1 ? arr.length - 1 : fromIndex;\n\n  const newArray = [...arr];\n  const element = newArray[fromIndex];\n  newArray.splice(fromIndex, 1);\n  newArray.splice(toIndex, 0, element);\n\n  return newArray;\n}\n\nexport const isObjectLiteral = (v: any): v is object => {\n  return typeof v === 'object' && v !== null && !Array.isArray(v) && typeof v !== 'function';\n};\n\nexport const defaultNamespaced = (actionType: string) => `normalized/${actionType}`;\n","import { ModelSchemaReader } from './schema';\nimport { isObjectLiteral } from './util';\nimport { Schema } from './interfaces';\nimport { Cardinalities } from './enums';\n\nexport const validateSchema = (schema: Schema) => {\n  if (!isObjectLiteral(schema)) {\n    throw new Error('schema must be an object literal');\n  }\n\n  Object.entries(schema).forEach(([type, entitySchema]) => {\n    if (!isObjectLiteral(entitySchema)) {\n      throw new Error(`schema of type \"${type}\" must be an object literal`);\n    }\n\n    Object.entries(entitySchema).forEach(([rel, relSchema]) => {\n      if (!isObjectLiteral(relSchema)) {\n        throw new Error(`schema of type \"${type}\" relation \"${rel}\" must be an object literal`);\n      }\n\n      if (!relSchema.hasOwnProperty('type')) {\n        throw new Error(`schema of type \"${type}\" relation \"${rel}\" is missing \"type\" attribute`);\n      }\n\n      if (!schema.hasOwnProperty(relSchema.type)) {\n        throw new Error(\n          `schema of type \"${type}\" relation \"${rel}\" relates to type \"${relSchema.type}\", but type \"${relSchema.type}\" does not have an entity schema of its own`\n        );\n      }\n\n      if (!relSchema.hasOwnProperty('cardinality')) {\n        throw new Error(`schema of type \"${type}\" relation \"${rel}\" is missing \"cardinality\" attribute`);\n      }\n\n      if (relSchema.cardinality !== Cardinalities.MANY && relSchema.cardinality !== Cardinalities.ONE) {\n        throw new Error(\n          `schema of type \"${type}\" relation \"${rel}\" cardinality must be either \"${Cardinalities.ONE}\" or \"${Cardinalities.MANY}\"`\n        );\n      }\n\n      if (!relSchema.hasOwnProperty('reciprocal')) {\n        throw new Error(`schema of type \"${type}\" relation \"${rel}\" is missing \"reciprocal\" attribute`);\n      }\n\n      if (!schema[relSchema.type][relSchema.reciprocal]) {\n        throw new Error(\n          `schema of type \"${type}\" relation \"${rel}\" has a reciprocal of \"${relSchema.reciprocal}\" on type \"${relSchema.type}\", but \"${relSchema.type}\" does not have a relation \"${relSchema.reciprocal}\"`\n        );\n      }\n\n      if (\n        schema[relSchema.type][relSchema.reciprocal] &&\n        schema[relSchema.type][relSchema.reciprocal].reciprocal !== rel\n      ) {\n        throw new Error(\n          `schema of type \"${type}\" relation \"${rel}\" has a reciprocal of \"${relSchema.reciprocal}\" on type \"${relSchema.type}\", but \"${relSchema.reciprocal}\" does not point back to \"${rel}\"`\n        );\n      }\n    });\n  });\n};\n\n// returns type data clean of that type's rel keys\n// does not clean out keys that are rel type names\nexport const cleanData = (data: any, schema: ModelSchemaReader, type: string) => {\n  return typeof data === 'object'\n    ? Object.keys(data).reduce((cleanData, key) => {\n        if (!schema.type(type).hasRelationKey(key)) {\n          cleanData[key] = data[key];\n        }\n        return cleanData;\n      }, {} as { [key: string]: any })\n    : {};\n};\n","import { Schema, EntitySchema, RelationSchema, EntitiesByType, IdsByType, State } from './interfaces';\n\nimport { Cardinalities } from './enums';\n\nimport { validateSchema } from './validator';\n\nexport class ModelSchemaReader {\n  schema: Schema;\n  entitySchemaReaders: Record<string, EntitySchemaReader>;\n\n  // singleton values\n  private emptyState?: State;\n  private emptyEntitiesByTypeState?: EntitiesByType;\n  private emptyIdsByTypeState?: IdsByType;\n\n  constructor(schema: Schema) {\n    validateSchema(schema);\n\n    this.schema = schema;\n\n    this.entitySchemaReaders = Object.entries(schema).reduce((entitySchemaReaders, [type, entitySchema]) => {\n      entitySchemaReaders[type] = new EntitySchemaReader(type, entitySchema, this);\n      return entitySchemaReaders;\n    }, {} as Record<string, EntitySchemaReader>);\n  }\n\n  typeExists(type: string) {\n    return this.getEntities().includes(type);\n  }\n\n  type(type: string) {\n    return this.entitySchemaReaders[type];\n  }\n\n  getEntities() {\n    return Object.keys(this.schema);\n  }\n\n  getEmptyEntitiesByTypeState() {\n    if (!this.emptyEntitiesByTypeState) {\n      this.emptyEntitiesByTypeState = this.getEntities().reduce((emptyState, type) => {\n        emptyState[type] = {};\n        return emptyState;\n      }, {} as EntitiesByType);\n    }\n\n    return this.emptyEntitiesByTypeState;\n  }\n\n  getEmptyIdsByTypeState() {\n    if (!this.emptyIdsByTypeState) {\n      this.emptyIdsByTypeState = this.getEntities().reduce((idsState, type) => {\n        idsState[type] = [];\n        return idsState;\n      }, {} as IdsByType);\n    }\n\n    return this.emptyIdsByTypeState;\n  }\n\n  getEmptyState<T extends State>(): T {\n    if (!this.emptyState) {\n      this.emptyState = {\n        entities: this.getEmptyEntitiesByTypeState(),\n        ids: this.getEmptyIdsByTypeState(),\n      } as T;\n    }\n\n    return this.emptyState as T;\n  }\n}\n\nexport class EntitySchemaReader {\n  type: string;\n  schema: EntitySchema;\n  modelSchemaReader: ModelSchemaReader;\n\n  constructor(type: string, schema: EntitySchema, modelSchemaReader: ModelSchemaReader) {\n    this.type = type;\n    this.schema = schema;\n    this.modelSchemaReader = modelSchemaReader;\n  }\n\n  getType() {\n    return this.type;\n  }\n\n  hasRelationKey(relationKey: string) {\n    return this.getRelationKeys().includes(relationKey);\n  }\n\n  resolveRelationKey(typeOrKey: string) {\n    const hasRelationKey = this.hasRelationKey(typeOrKey);\n    if (hasRelationKey) {\n      return typeOrKey;\n    }\n\n    const relationType = typeOrKey;\n\n    // Iterate the relation schemas to find the one whose entity is the relationType.\n    // It is possible that multiple relation schemas point to the same type, and consequently,\n    // multiple keys would point to the type; in such a case we would return undefined.\n    let found = undefined;\n    for (let relationKey of this.getRelationKeys()) {\n      const relationSchema = this.getRelationSchema(relationKey);\n\n      if (relationSchema.type === relationType) {\n        if (found) {\n          // If a previously iterated relation schema has the given type\n          // then it means multiple relation schemas point to the given type,\n          // and a single key can be returned. For now, return undefined. Maybe\n          // later implement returning an array of keys.\n          return undefined;\n        }\n\n        // flag that a schema of the given type has been found\n        found = relationKey;\n      }\n    }\n\n    return found;\n  }\n\n  resolveRelationType(typeOrKey: string) {\n    // if given a key, then just get the type by key\n    const hasRelationKey = this.hasRelationKey(typeOrKey);\n    if (hasRelationKey) {\n      return this.getRelationType(typeOrKey);\n    }\n\n    // if given a type, then iterate each schema to see\n    // whether a relation schema contains the type,\n    // and if so the just return the type\n    const relationType = typeOrKey;\n    for (let relationSchema of this.relationSchemas()) {\n      if (relationSchema.type === relationType) {\n        return relationType;\n      }\n    }\n\n    return undefined;\n  }\n\n  resolveRelationCardinality(typeOrKey: string) {\n    const relationKey = this.resolveRelationKey(typeOrKey);\n    if (!relationKey) {\n      return undefined;\n    }\n\n    return this.getRelationCardinality(relationKey);\n  }\n\n  resolveRelationReciprocalKey(typeOrKey: string) {\n    const relationKey = this.resolveRelationKey(typeOrKey);\n    if (!relationKey) {\n      return undefined;\n    }\n\n    return this.getRelationReciprocalKey(relationKey);\n  }\n\n  resolveReciprocalCardinality(typeOrKey: string) {\n    const relationKey = this.resolveRelationKey(typeOrKey);\n    if (!relationKey) {\n      return undefined;\n    }\n\n    const relationType = this.getRelationType(relationKey);\n    const relationReciprocalKey = this.getRelationReciprocalKey(relationKey);\n\n    if (!relationType || !relationReciprocalKey) {\n      return undefined;\n    }\n\n    return this.modelSchemaReader.type(relationType).getRelationCardinality(relationReciprocalKey);\n  }\n\n  getRelationKeys() {\n    return Object.keys(this.schema);\n  }\n\n  relationSchemas(): RelationSchema[] {\n    return Object.values(this.schema);\n  }\n\n  getRelationSchema(relationKey: string): RelationSchema {\n    return this.schema[relationKey];\n  }\n\n  getRelationCardinality(relationKey: string) {\n    return this.getRelationSchemaField(relationKey, 'cardinality');\n  }\n\n  getRelationType(relationKey: string) {\n    return this.getRelationSchemaField(relationKey, 'type');\n  }\n\n  getRelationReciprocalKey(relationKey: string) {\n    return this.getRelationSchemaField(relationKey, 'reciprocal');\n  }\n\n  //\n  // state-getters\n  //\n\n  getEmptyEntityState(emptyRels?: boolean) {\n    if (!emptyRels) {\n      return {};\n    }\n\n    return Object.entries(this.schema).reduce((state, [reltype, relSchema]) => {\n      if (relSchema.cardinality === Cardinalities.ONE) {\n        state[reltype] = undefined;\n      }\n\n      if (relSchema.cardinality === Cardinalities.MANY) {\n        state[reltype] = [];\n      }\n\n      return state;\n    }, {} as { [k: string]: any });\n  }\n\n  getEmptyRelationState(relationKey: string) {\n    const cardinality = this.getRelationCardinality(relationKey);\n    return cardinality === Cardinalities.ONE ? undefined : [];\n  }\n\n  private getRelationSchemaField(relationKey: string, field: keyof RelationSchema) {\n    const relationSchema = this.getRelationSchema(relationKey);\n\n    if (!relationSchema) {\n      return undefined;\n    }\n\n    return relationSchema[field] as string;\n  }\n}\n","import { ModelSchemaReader } from './schema';\nimport {\n  Id,\n  State,\n  Selectors,\n  Entity,\n  GetAllAttachedIds,\n  SelectorTreeSchema,\n  EntityTreeNode,\n  PublicSelectors,\n  InternalSelectors,\n} from './interfaces';\n\nconst emptyIds: Id[] = [];\nconst emptyEntities = {};\n\nexport const makeSelectors = <S extends State>(schema: ModelSchemaReader): Selectors<S> => {\n  const getIds = (state: S, args: { type: string }): Id[] => {\n    const typeExists = schema.typeExists(args.type);\n    if (!typeExists) {\n      return emptyIds;\n    }\n\n    const ids = state.ids[args.type] as Id[];\n\n    return ids || emptyIds;\n  };\n\n  const getEntities = <E extends Entity>(state: S, args: { type: string }): Record<Id, E> => {\n    const typeExists = schema.typeExists(args.type);\n    if (!typeExists) {\n      return emptyEntities;\n    }\n\n    const entities = state.entities[args.type];\n\n    return (entities || emptyEntities) as Record<Id, E>;\n  };\n\n  const getEntity = <E extends Entity>(state: S, args: { type: string; id: Id }): E | undefined => {\n    const typeExists = schema.typeExists(args.type);\n    if (!typeExists) {\n      return undefined;\n    }\n\n    const entities = getEntities<E>(state, args);\n\n    return entities[args.id] as E;\n  };\n\n  const getAttached = <E extends Id[] | Id>(\n    state: S,\n    args: { type: string; id: Id; relation: string }\n  ): E | undefined => {\n    const entitySchema = schema.type(args.type);\n    if (!entitySchema) {\n      return undefined;\n    }\n\n    const relationKey = entitySchema.resolveRelationKey(args.relation);\n    if (!relationKey) {\n      return undefined;\n    }\n\n    const entity = getEntity(state, args);\n\n    if (!entity) {\n      return undefined;\n    }\n\n    return entity[relationKey];\n  };\n\n  const getAttachedIds = (state: S, args: { type: string; id: Id; relation: string }) => {\n    const { type, id, relation } = args;\n\n    const relationKey = schema.type(type).resolveRelationKey(relation);\n\n    if (!relationKey) {\n      return [];\n    }\n\n    const attached = getAttached(state, { type, id, relation: relationKey });\n\n    if (attached && typeof attached === 'string') {\n      return [attached];\n    }\n\n    if (attached && Array.isArray(attached)) {\n      return attached;\n    }\n\n    return [];\n  };\n\n  const getAllAttachedIds: GetAllAttachedIds<S> = (state, { type, id }) => {\n    const entitySchema = schema.type(type);\n    if (!entitySchema) {\n      return {};\n    }\n\n    const allAttachedIds: { [relationKey: string]: Id[] } = {};\n\n    const relationKeys = entitySchema.getRelationKeys();\n    for (let relationKey of relationKeys) {\n      const attachedIds = getAttachedIds(state, { type, id, relation: relationKey });\n      if (attachedIds.length) {\n        allAttachedIds[relationKey] = attachedIds;\n      }\n    }\n\n    return allAttachedIds;\n  };\n\n  const getEntityTree = (\n    state: S,\n    args: { type: string; id: Id; schema: SelectorTreeSchema }\n  ): EntityTreeNode[] => {\n    const { type, id, schema: selectorSchema } = args;\n\n    if (!schema.type(type)) {\n      return [];\n    }\n\n    const rootEntity = getEntity<S>(state, { type, id });\n\n    if (!rootEntity) {\n      return [];\n    }\n\n    const nodes = recursivelyGetNodes(state, type, id, selectorSchema);\n\n    return Object.values(nodes);\n  };\n\n  const recursivelyGetNodes = (\n    state: S,\n    type: string,\n    id: Id,\n    selectorSchema: SelectorTreeSchema,\n    nodes: Record<string, EntityTreeNode> = {}\n  ): Record<string, EntityTreeNode> => {\n    const entity = getEntity(state, { type, id });\n\n    if (!entity) {\n      return nodes;\n    }\n\n    nodes[`${type}.${id}`] = { id, type, entity };\n\n    if (typeof selectorSchema === 'function') {\n      selectorSchema = selectorSchema();\n    }\n\n    for (let [relation, nestedSelectorSchema] of Object.entries(selectorSchema)) {\n      const relationKey = schema.type(type).resolveRelationKey(relation);\n      const relationType = schema.type(type).resolveRelationType(relation);\n\n      if (relationKey && relationType) {\n        const attachedIds = getAttachedIds(state, { type, id, relation: relationKey });\n        for (let attachedId of attachedIds) {\n          recursivelyGetNodes(state, relationType, attachedId, nestedSelectorSchema, nodes);\n        }\n      }\n    }\n\n    return nodes;\n  };\n\n  return {\n    getIds,\n    getEntities,\n    getEntity,\n    getAttached,\n    getAllAttachedIds,\n    getEntityTree,\n  };\n};\n\nexport const getPublicSelectors = <S extends State>(selectors: Selectors<S>): PublicSelectors<S> => {\n  const { getIds, getEntities, getEntity } = selectors;\n\n  return {\n    getIds,\n    getEntities,\n    getEntity,\n  };\n};\n\nexport const getInternalSelectors = <S extends State>(selectors: Selectors<S>): InternalSelectors<S> => {\n  const { getEntityTree, getAllAttachedIds, getAttached } = selectors;\n\n  return {\n    getEntityTree,\n    getAllAttachedIds,\n    getAttached,\n  };\n};\n","export const entityTypeDne = (entityType: string) => `Entity-type \"${entityType}\" does not exist`;\n\nexport const relDne = (entityType: string, rel: string) =>\n  `Entity \"${entityType}\" does not have a relation named \"${rel}\"`;\n\nexport const indexLtZero = (name: string) => `${name} index is less than 0`;\n","import {\n  Id,\n  State,\n  Namespaced,\n  InvalidActionCreator,\n  AttachActionCreator,\n  AttachAction,\n  DetachActionCreator,\n  DetachAction,\n  DeleteAction,\n  DeleteActionCreator,\n  AnyAction,\n  ActionTypes,\n  SelectorTreeSchema,\n  CreateActionCreator,\n  CreateAction,\n  UpdateActionCreator,\n  UpdateAction,\n  MoveAction,\n  MoveActionCreator,\n  MoveAttachedAction,\n  MoveAttachedActionCreator,\n  SortActionCreator,\n  Entity,\n  Compare,\n  SortAttachedActionCreator,\n  BatchActionCreator,\n  SingularAction,\n  SortAction,\n  SetStateActionCreator,\n  InvalidAction,\n  SortAttachedAction,\n  BatchAction,\n} from './interfaces';\nimport { ModelSchemaReader } from './schema';\nimport * as messages from './messages';\nimport { UpdateActionMethod } from './enums';\nimport { cleanData } from './validator';\n\nexport const makeActions = <S extends State>(schema: ModelSchemaReader, namespaced: Namespaced) => {\n  const BATCH = namespaced('BATCH');\n  const INVALID = namespaced('INVALID');\n  const ATTACH = namespaced('ATTACH');\n  const DETACH = namespaced('DETACH');\n  const DELETE = namespaced('DELETE');\n  const CREATE = namespaced('CREATE');\n  const UPDATE = namespaced('UPDATE');\n  const MOVE = namespaced('MOVE');\n  const MOVE_ATTACHED = namespaced('MOVE_ATTACHED');\n  const SORT = namespaced('SORT');\n  const SORT_ATTACHED = namespaced('SORT_ATTACHED');\n  const SET_STATE = namespaced('SET_STATE');\n\n  const invalid: InvalidActionCreator = (action, error) => ({\n    type: INVALID,\n    error,\n    action,\n  });\n\n  const batch: BatchActionCreator = (\n    ...actions: (SingularAction | InvalidAction | BatchAction)[]\n  ): BatchAction => {\n    const flattened = flattenActions(actions);\n    return {\n      type: BATCH,\n      actions: flattened,\n    };\n  };\n\n  function flattenActions(\n    actions: (SingularAction | InvalidAction | BatchAction)[]\n  ): (SingularAction | InvalidAction)[] {\n    const accumulator: (SingularAction | InvalidAction)[] = [];\n\n    actions.forEach(action => {\n      if (action.type === BATCH) {\n        const batchAction = action as BatchAction;\n        const flattened = flattenActions(batchAction.actions);\n        accumulator.push(...flattened);\n      } else {\n        accumulator.push(action as SingularAction | InvalidAction);\n      }\n    });\n\n    return accumulator;\n  }\n\n  const attach: AttachActionCreator = (entityType, id, relation, attachableId, options = {}) => {\n    const action: AttachAction = {\n      type: ATTACH,\n      entityType,\n      id,\n      relation,\n      attachableId,\n      index: options.index,\n      reciprocalIndex: options.reciprocalIndex,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    if (!schema.type(entityType).resolveRelationKey(relation)) {\n      return invalid(action, messages.relDne(entityType, relation));\n    }\n\n    return action;\n  };\n\n  const detach: DetachActionCreator = (entityType, id, relation, detachableId) => {\n    const action: DetachAction = {\n      type: DETACH,\n      entityType,\n      id,\n      relation,\n      detachableId,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    if (!schema.type(entityType).resolveRelationKey(relation)) {\n      return invalid(action, messages.relDne(entityType, relation));\n    }\n\n    return action;\n  };\n\n  const del: DeleteActionCreator = (entityType, id, cascade?: SelectorTreeSchema) => {\n    const action: DeleteAction = {\n      type: DELETE,\n      entityType,\n      id,\n      cascade,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    return action;\n  };\n\n  const create: CreateActionCreator = (entityType, id, data = {}, index?) => {\n    const action: CreateAction = {\n      type: CREATE,\n      entityType,\n      id,\n      data,\n      index,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    // data must be an object with only non-relational attributes\n    action.data = cleanData(data, schema, entityType);\n\n    return action;\n  };\n\n  const update: UpdateActionCreator = (entityType, id, data, options = {}) => {\n    const action: UpdateAction = {\n      type: UPDATE,\n      entityType,\n      id,\n      data,\n      method: options.method || UpdateActionMethod.PATCH,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    // data must be an object with only non-relational attributes\n    action.data = cleanData(data, schema, entityType);\n\n    return action;\n  };\n\n  const move: MoveActionCreator = (entityType, src, dest) => {\n    const action: MoveAction = {\n      type: MOVE,\n      entityType,\n      src,\n      dest,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    if (src < 0) {\n      return invalid(action, messages.indexLtZero('source'));\n    }\n\n    if (dest < 0) {\n      return invalid(action, messages.indexLtZero('destination'));\n    }\n\n    return action;\n  };\n\n  const moveAttached: MoveAttachedActionCreator = (entityType, id, relation, src, dest) => {\n    const action: MoveAttachedAction = {\n      type: MOVE_ATTACHED,\n      entityType,\n      id,\n      relation,\n      src,\n      dest,\n    };\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    if (!schema.type(entityType).resolveRelationKey(relation)) {\n      return invalid(action, messages.relDne(entityType, relation));\n    }\n\n    if (src < 0) {\n      return invalid(action, messages.indexLtZero('source'));\n    }\n\n    if (dest < 0) {\n      return invalid(action, messages.indexLtZero('destination'));\n    }\n\n    return action;\n  };\n\n  const sort: SortActionCreator = <T extends Entity = Entity>(entityType: string, compare: Compare<T>) => {\n    const action = {\n      type: SORT,\n      entityType,\n      compare,\n    } as SortAction;\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action as SortAction, messages.entityTypeDne(entityType));\n    }\n\n    return action;\n  };\n\n  const sortAttached: SortAttachedActionCreator = <T extends Entity = Entity>(\n    entityType: string,\n    id: Id,\n    relation: string,\n    compare: Compare<T>\n  ) => {\n    const action = {\n      type: SORT_ATTACHED,\n      entityType,\n      id,\n      relation,\n      compare,\n    } as SortAttachedAction;\n\n    if (!schema.typeExists(entityType)) {\n      return invalid(action, messages.entityTypeDne(entityType));\n    }\n\n    if (!schema.type(entityType).resolveRelationKey(relation)) {\n      return invalid(action, messages.relDne(entityType, relation));\n    }\n\n    return action;\n  };\n\n  const setState: SetStateActionCreator<S> = (state: S) => {\n    return {\n      type: SET_STATE,\n      state,\n    };\n  };\n\n  const actionTypes = {\n    BATCH,\n    INVALID,\n    ATTACH,\n    DETACH,\n    DELETE,\n    CREATE,\n    UPDATE,\n    MOVE,\n    MOVE_ATTACHED,\n    SORT,\n    SORT_ATTACHED,\n    SET_STATE,\n  };\n\n  const actionCreators = {\n    batch,\n    attach,\n    detach,\n    delete: del,\n    create,\n    update,\n    move,\n    moveAttached,\n    sort,\n    sortAttached,\n    setState,\n  };\n\n  const actionUtils = new ActionUtils(actionTypes);\n\n  return {\n    actionTypes,\n    actionCreators,\n    actionUtils,\n  };\n};\n\nexport class ActionUtils {\n  actionTypes: ActionTypes;\n\n  constructor(actionTypes: ActionTypes) {\n    this.actionTypes = actionTypes;\n  }\n\n  isHandleable(action: AnyAction) {\n    return Object.values(this.actionTypes).includes(action.type);\n  }\n\n  isDerivable(action: AnyAction) {\n    const { DETACH, DELETE, ATTACH } = this.actionTypes;\n    return [DETACH, DELETE, ATTACH].includes(action.type);\n  }\n\n  isBatch(action: AnyAction) {\n    return action.type === this.actionTypes.BATCH;\n  }\n\n  isStateSetter(action: AnyAction) {\n    return action.type === this.actionTypes.SET_STATE;\n  }\n}\n","import {\n  Id,\n  State,\n  AnyAction,\n  DerivedAction,\n  ActionTypes,\n  AttachAction,\n  DetachAction,\n  Selectors,\n  ActionCreators,\n  DeleteAction,\n  InvalidAction,\n  EntityTreeNode,\n} from './interfaces';\n\nimport { Cardinalities } from './enums';\n\nimport { ModelSchemaReader } from './schema';\n\nexport default class Derivator<S extends State> {\n  actionTypes: ActionTypes;\n  actionCreators: ActionCreators<S>;\n  schema: ModelSchemaReader;\n  selectors: Selectors<S>;\n\n  constructor(\n    actionTypes: ActionTypes,\n    actionCreators: ActionCreators<S>,\n    schema: ModelSchemaReader,\n    selectors: Selectors<S>\n  ) {\n    this.actionTypes = actionTypes;\n    this.actionCreators = actionCreators;\n    this.schema = schema;\n    this.selectors = selectors;\n  }\n\n  public deriveAction(state: S, action: AnyAction): DerivedAction | AnyAction {\n    if (action.type === this.actionTypes.DETACH) {\n      const detachAction = action as DetachAction;\n      const derivedActions = this.deriveDetachActions(detachAction);\n      return {\n        type: action.type,\n        original: action,\n        derived: derivedActions,\n      } as DerivedAction<DetachAction>;\n    }\n\n    if (action.type === this.actionTypes.ATTACH) {\n      const attachAction = action as AttachAction;\n      const derivedActions = this.deriveAttachActions(state, attachAction);\n\n      return {\n        type: action.type,\n        original: action,\n        derived: derivedActions,\n      } as DerivedAction<AttachAction>;\n    }\n\n    if (action.type === this.actionTypes.DELETE) {\n      const deleteAction = action as DeleteAction;\n\n      // derive the actions that go along with deleting this entity\n      let derivedActions: (InvalidAction | DeleteAction | DetachAction)[] = [];\n\n      if (!deleteAction.cascade) {\n        derivedActions = this.deriveDeleteActions(state, deleteAction);\n      }\n\n      // if cascading deletion, then derive all those actions\n      if (deleteAction.cascade) {\n        const cascadeNodes: EntityTreeNode[] = this.selectors.getEntityTree(state, {\n          type: deleteAction.entityType,\n          id: deleteAction.id,\n          schema: deleteAction.cascade,\n        });\n\n        const cascadeActions: (InvalidAction | DeleteAction | DetachAction)[] = [];\n        cascadeNodes.forEach(({ id, type }) => {\n          const cascadeAction = this.actionCreators.delete(type, id);\n          if (cascadeAction.type === this.actionTypes.DELETE) {\n            const cascadeDeleteAction = cascadeAction as DeleteAction;\n            cascadeActions.push(...this.deriveDeleteActions(state, cascadeDeleteAction));\n          }\n        });\n\n        derivedActions.push(...cascadeActions);\n      }\n\n      return {\n        type: action.type,\n        original: action,\n        derived: derivedActions,\n      } as DerivedAction<DeleteAction>;\n    }\n\n    return action;\n  }\n\n  private deriveDetachActions(action: DetachAction): (DetachAction | InvalidAction)[] {\n    const { entityType, id, relation, detachableId } = action;\n\n    const schema = this.schema.type(entityType);\n\n    const relationType = schema.resolveRelationType(relation);\n    const reciprocalKey = schema.resolveRelationReciprocalKey(relation);\n\n    if (!relationType || !reciprocalKey) {\n      return [action];\n    }\n\n    const reciprocalAction = this.actionCreators.detach(relationType, detachableId, reciprocalKey, id);\n\n    return [action, reciprocalAction];\n  }\n\n  private deriveAttachActions(\n    state: S,\n    action: AttachAction\n  ): (AttachAction | DetachAction | InvalidAction)[] {\n    const { entityType, id, relation, attachableId } = action;\n\n    const schema = this.schema.type(entityType);\n\n    const relationType = schema.resolveRelationType(relation);\n    if (!relationType) {\n      return [];\n    }\n\n    // check existence of entity\n    const entity = this.selectors.getEntity(state, { type: entityType, id });\n    if (!entity) {\n      return [];\n    }\n\n    // check existence of attachable entity\n    const attachableEntity = this.selectors.getEntity(state, {\n      type: relationType,\n      id: attachableId,\n    });\n    const reciprocalKey = schema.resolveRelationReciprocalKey(relation);\n    if (!attachableEntity || !reciprocalKey) {\n      return [];\n    }\n\n    //\n    // make the attach-action\n    //\n    const relAttachAction = this.actionCreators.attach(relationType, attachableId, reciprocalKey, id, {\n      index: action.reciprocalIndex,\n      reciprocalIndex: action.index,\n    });\n\n    //\n    // make the detach-actions for the occupant entities\n    //\n    const entityDetachments = this.detachOccupant(state, entityType, id, relation);\n    const relEntityDetachments = this.detachOccupant(state, relationType, attachableId, reciprocalKey);\n\n    return [action, relAttachAction, ...entityDetachments, ...relEntityDetachments];\n  }\n\n  private deriveDeleteActions(\n    state: S,\n    action: DeleteAction\n  ): (InvalidAction | DeleteAction | DetachAction)[] {\n    const { entityType, id } = action;\n\n    const entitySchema = this.schema.type(entityType);\n    if (!entitySchema) {\n      return [];\n    }\n\n    // get all attached entities\n    const attachedIdsByRelationKey = this.selectors.getAllAttachedIds(state, {\n      type: entityType,\n      id,\n    });\n\n    // derive detachment actions\n    const detachActions: (DetachAction | InvalidAction)[] = Object.entries<Id[]>(\n      attachedIdsByRelationKey\n    ).reduce((allDetachActions, [relationKey, attachedIds]) => {\n      const relationType = entitySchema.resolveRelationType(relationKey);\n      if (!relationType) {\n        return allDetachActions;\n      }\n\n      const reciprocalKey = entitySchema.resolveRelationReciprocalKey(relationKey);\n      if (!reciprocalKey) {\n        return allDetachActions;\n      }\n\n      const detachActions = attachedIds.map(attachedId =>\n        this.actionCreators.detach(relationType, attachedId, reciprocalKey, id)\n      );\n\n      allDetachActions.push(...detachActions);\n\n      return allDetachActions;\n    }, [] as (DetachAction | InvalidAction)[]);\n\n    return [action, ...detachActions];\n  }\n\n  private detachOccupant(state: S, entityType: string, id: Id, relation: string) {\n    const schema = this.schema.type(entityType);\n    const relationType = schema.resolveRelationType(relation);\n    const relationReciprocalKey = schema.resolveRelationReciprocalKey(relation);\n    const cardinality = schema.resolveRelationCardinality(relation);\n\n    if (!relationType || !relationReciprocalKey || cardinality === Cardinalities.MANY) {\n      return [];\n    }\n\n    let occupantId = this.selectors.getAttached<Id>(state, {\n      type: entityType,\n      id,\n      relation,\n    });\n    if (!occupantId) {\n      return [];\n    }\n\n    return [\n      this.actionCreators.detach(entityType, id, relationType, occupantId),\n      this.actionCreators.detach(relationType, occupantId, relationReciprocalKey, id),\n    ];\n  }\n}\n","import { Schema, Namespaced, State } from './interfaces';\nimport { ModelSchemaReader } from './schema';\nimport { makeSelectors, getPublicSelectors } from './selectors';\nimport { makeActions } from './actions';\nimport Derivator from './derivator';\nimport { makeReducer } from './reducer';\n\nconst defaultNamespaced = (actionType: string) => `normalized/${actionType}`;\n\nconst makeNormalizedSlice = <S extends State>(schema: Schema, namespaced: Namespaced = defaultNamespaced) => {\n  const schemaReader = new ModelSchemaReader(schema);\n  const { actionTypes, actionCreators, actionUtils } = makeActions<S>(schemaReader, namespaced);\n  const allSelectors = makeSelectors<S>(schemaReader);\n  const selectors = getPublicSelectors<S>(allSelectors);\n  const emptyState = schemaReader.getEmptyState<S>();\n  const derivator = new Derivator<S>(actionTypes, actionCreators, schemaReader, allSelectors);\n  const reducer = makeReducer<S>(schemaReader, derivator, actionTypes, actionUtils);\n\n  return {\n    emptyState,\n    selectors,\n    actionTypes,\n    actionCreators,\n    reducer,\n  };\n};\n\nexport * from './interfaces';\nexport * from './enums';\nexport * from './normalizr';\n\nexport default makeNormalizedSlice;\n","import {\n  ActionTypes,\n  AnyAction,\n  AttachAction,\n  BatchAction,\n  CreateAction,\n  DeleteAction,\n  DerivedAction,\n  DetachAction,\n  EntitiesByType,\n  Entity,\n  Id,\n  IdsByType,\n  InvalidAction,\n  MoveAction,\n  MoveAttachedAction,\n  SetStateAction,\n  SingularAction,\n  SortAction,\n  SortAttachedAction,\n  State,\n  UpdateAction,\n  Reducer,\n} from './interfaces';\nimport { ModelSchemaReader } from './schema';\nimport Derivator from './derivator';\nimport { ActionUtils } from './actions';\nimport { Cardinalities, UpdateActionMethod } from './enums';\nimport { arrayMove, arrayPut } from './util';\n\nexport const makeReducer = <S extends State>(\n  schema: ModelSchemaReader,\n  derivator: Derivator<S>,\n  actionTypes: ActionTypes,\n  actionUtils: ActionUtils\n) => {\n  const rootReducer: Reducer<S> = (state: S = schema.getEmptyState(), action: AnyAction): S => {\n    // if not handleable, then return state without changes\n    if (!actionUtils.isHandleable(action)) {\n      return state;\n    }\n\n    if (actionUtils.isStateSetter(action)) {\n      if (action.type === actionTypes.SET_STATE) {\n        return (action as SetStateAction<S>).state;\n      }\n    }\n\n    if (actionUtils.isBatch(action)) {\n      // with a batch action, reduce iteratively\n      const batchAction = action as BatchAction;\n      return batchAction.actions.reduce((prevState: S, action: SingularAction | InvalidAction) => {\n        return singularReducer(prevState, action);\n      }, state);\n    } else {\n      // with a singular action, reduce once\n      return singularReducer(state, action as SingularAction);\n    }\n  };\n\n  function singularReducer(state: S, action: SingularAction | InvalidAction): S {\n    const singularAction = action as SingularAction;\n\n    let actions: SingularAction[];\n    if (actionUtils.isDerivable(singularAction)) {\n      const derivedAction = derivator.deriveAction(state, singularAction) as DerivedAction;\n      actions = derivedAction.derived;\n    } else {\n      actions = [singularAction];\n    }\n\n    // reduce [action]\n    return actions.reduce((prevState: S, action: SingularAction) => {\n      // sort has to be handled here because it needs both slices\n      if (action.type === actionTypes.SORT) {\n        const { entityType, compare } = action as SortAction;\n\n        const ids = prevState.ids[entityType];\n        const entities = prevState.entities[entityType];\n        const sortedIds = [...ids].sort((idA, idB) => {\n          const entityA = entities[idA];\n          const entityB = entities[idB];\n\n          // comparison error will need to be handled in the future\n          // ...\n\n          return compare(entityA, entityB);\n        });\n\n        return {\n          entities: prevState.entities,\n          ids: {\n            ...prevState.ids,\n            [entityType]: sortedIds,\n          },\n        } as S;\n      }\n\n      // all other actions handled here\n      return {\n        entities: entitiesReducer(prevState.entities, action),\n        ids: idsReducer(prevState.ids, action),\n      } as S;\n    }, state);\n  }\n\n  const defaultEntitiesState = schema.getEmptyEntitiesByTypeState();\n  function entitiesReducer(\n    state: EntitiesByType = defaultEntitiesState,\n    action: SingularAction\n  ): EntitiesByType {\n    if (action.type === actionTypes.INVALID) {\n      return state;\n    }\n\n    if (!schema.typeExists(action.entityType)) {\n      return state; // if no such entityType, then no change\n    }\n\n    if (action.type === actionTypes.DETACH) {\n      const { entityType, id, detachableId, relation } = action as DetachAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      const relationKey = schema.type(entityType).resolveRelationKey(relation);\n      if (!relationKey) {\n        return state; // if entity relation key not found, then no change\n      }\n\n      let newEntity = entity; // to contain the change immutably\n\n      const cardinality = schema.type(entityType).resolveRelationCardinality(relation);\n\n      if (cardinality === Cardinalities.ONE) {\n        const attachedId = entity[relationKey] as Id;\n\n        if (detachableId !== attachedId) {\n          return state; // if detachableId is not the attached id, then no change\n        }\n\n        // detach it: set the relation value to undefined\n        newEntity = { ...entity, [relationKey]: undefined };\n      }\n\n      if (cardinality === Cardinalities.MANY) {\n        const attachedIds = (entity[relationKey] || []) as Id[];\n\n        // detach it: filter out the detachableId\n        newEntity = {\n          ...entity,\n          [relationKey]: attachedIds.filter(attachedId => attachedId !== detachableId),\n        };\n      }\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: newEntity,\n        },\n      };\n    }\n\n    if (action.type === actionTypes.ATTACH) {\n      const { entityType, id, attachableId, relation, index } = action as AttachAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      const relationKey = schema.type(entityType).resolveRelationKey(relation);\n      if (!relationKey) {\n        return state; // if entity relation key not found, then no change\n      }\n\n      let newEntity = entity; // to contain the change immutably\n\n      const cardinality = schema.type(entityType).resolveRelationCardinality(relation);\n\n      if (cardinality === Cardinalities.ONE) {\n        newEntity = {\n          ...newEntity,\n          [relationKey]: attachableId,\n        };\n      }\n\n      if (cardinality === Cardinalities.MANY) {\n        if (!entity[relationKey] || !entity[relationKey].includes(attachableId)) {\n          newEntity = {\n            ...newEntity,\n            [relationKey]: arrayPut(attachableId, newEntity[relationKey], index),\n          };\n        }\n      }\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: newEntity,\n        },\n      };\n    }\n\n    if (action.type === actionTypes.DELETE) {\n      const { entityType, id } = action as DeleteAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      const entitiesOfType = { ...state[entityType] };\n      delete entitiesOfType[id];\n\n      return {\n        ...state,\n        [entityType]: entitiesOfType,\n      };\n    }\n\n    if (action.type === actionTypes.CREATE) {\n      const { entityType, id, data } = action as CreateAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (entity) {\n        return state; // if entity exists, then no change\n      }\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: data || {},\n        },\n      };\n    }\n\n    if (action.type === actionTypes.UPDATE) {\n      const { entityType, id, data, method } = action as UpdateAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      let newEntity = { ...entity };\n\n      if (method === UpdateActionMethod.PUT) {\n        // extract the current relational data, so we have a copy of it and it won't get overwritten\n        const relationKeys = schema.type(entityType).getRelationKeys();\n        const relationalData = relationKeys.reduce((relationalData, relationKey) => {\n          if (entity[relationKey]) {\n            relationalData[relationKey] = entity[relationKey];\n          }\n          return relationalData;\n        }, {} as { [k: string]: Id | Id[] });\n\n        // replace the current entity with the update data and the relational data\n        newEntity = { ...data, ...relationalData };\n      }\n\n      if (method === UpdateActionMethod.PATCH) {\n        // merge the update data with the current data\n        newEntity = { ...entity, ...data };\n      }\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: newEntity,\n        },\n      };\n    }\n\n    if (action.type === actionTypes.MOVE_ATTACHED) {\n      const { entityType, id, relation, src, dest } = action as MoveAttachedAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      const relationKey = schema.type(entityType).resolveRelationKey(relation);\n      if (!relationKey) {\n        return state; // if entity relation key not found, then no change\n      }\n\n      const cardinality = schema.type(entityType).resolveRelationCardinality(relation);\n      if (cardinality === Cardinalities.ONE) {\n        return state; // if cardinality is one, then no change\n      }\n\n      const attachedIds = entity[relationKey];\n      if (!Array.isArray(attachedIds)) {\n        return state; // if attached ids is not an array, then no change\n      }\n\n      const newEntity = {\n        ...entity,\n        [relationKey]: arrayMove(attachedIds, src, dest),\n      };\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: newEntity,\n        },\n      };\n    }\n\n    if (action.type === actionTypes.SORT_ATTACHED) {\n      const { entityType, id, relation, compare } = action as SortAttachedAction;\n\n      const entity = state[entityType][id] as Entity;\n      if (!entity) {\n        return state; // if entity not found, then no change\n      }\n\n      const relationKey = schema.type(entityType).resolveRelationKey(relation);\n      const relationType = schema.type(entityType).resolveRelationType(relation);\n      if (!relationKey || !relationType) {\n        return state; // if entity relation key or relation type not found, then no change\n      }\n\n      const cardinality = schema.type(entityType).resolveRelationCardinality(relation);\n      if (cardinality === Cardinalities.ONE) {\n        return state; // if cardinality is one, then no change\n      }\n\n      const attachedIds = entity[relationKey];\n      if (!Array.isArray(attachedIds)) {\n        return state; // if attached ids is not an array, then no change\n      }\n\n      const relatedEntities = state[relationType];\n      const sortedIds = [...attachedIds].sort((idA, idB) => {\n        const entityA = relatedEntities[idA];\n        const entityB = relatedEntities[idB];\n\n        // comparison error will need to be handled in the future\n        // ...\n\n        return compare(entityA, entityB);\n      });\n\n      const newEntity = {\n        ...entity,\n        [relationKey]: sortedIds,\n      };\n\n      return {\n        ...state,\n        [entityType]: {\n          ...state[entityType],\n          [id]: newEntity,\n        },\n      };\n    }\n\n    return state;\n  }\n\n  const defaultIdsState = schema.getEmptyIdsByTypeState();\n  function idsReducer(state: IdsByType = defaultIdsState, action: SingularAction): IdsByType {\n    if (action.type === actionTypes.INVALID) {\n      return state;\n    }\n\n    if (!schema.typeExists(action.entityType)) {\n      return state; // if no such entityType, then no change\n    }\n\n    if (action.type === actionTypes.DELETE) {\n      const { entityType, id } = action as DeleteAction;\n\n      const idsOfEntity = state[entityType].filter(existingId => existingId !== id);\n\n      return {\n        ...state,\n        [entityType]: idsOfEntity,\n      };\n    }\n\n    if (action.type === actionTypes.CREATE) {\n      const { entityType, id, index } = action as CreateAction;\n\n      // this O(n) operation can be improved if existence is checked\n      // in an O(c) lookup against the entities slice from one level up,\n      // and then set the existence boolean on the action\n      if (state[entityType].includes(id)) {\n        return state; // if entity exists, then no change\n      }\n\n      return {\n        ...state,\n        [entityType]: arrayPut(id, state[entityType], index),\n      };\n    }\n\n    if (action.type === actionTypes.MOVE) {\n      const { entityType, src, dest } = action as MoveAction;\n\n      return {\n        ...state,\n        [entityType]: arrayMove(state[entityType], src, dest),\n      };\n    }\n\n    return state;\n  }\n\n  return rootReducer;\n};\n","import { EntitiesByType, State, Entities } from './interfaces';\n\nexport interface NormalizrOutput {\n  entities: EntitiesByType;\n}\n\nexport const fromNormalizr = <T extends State>(data: NormalizrOutput): T => {\n  const { entities: entitiesByType } = data;\n\n  const state: State = {\n    entities: {},\n    ids: {},\n  };\n\n  Object.entries<Entities>(entitiesByType).forEach(([type, entities]) => {\n    state.entities[type] = entities;\n    state.ids[type] = Object.keys(entities);\n  });\n\n  return state as T;\n};\n"],"names":["Cardinalities","UpdateActionMethod","arrayPut","item","array","index","newArray","undefined","push","splice","arrayMove","arr","fromIndex","toIndex","length","element","isObjectLiteral","v","Array","isArray","cleanData","data","schema","type","Object","keys","reduce","key","hasRelationKey","ModelSchemaReader","Error","entries","forEach","entitySchema","rel","relSchema","hasOwnProperty","cardinality","MANY","ONE","reciprocal","validateSchema","entitySchemaReaders","EntitySchemaReader","_this","typeExists","this","getEntities","includes","getEmptyEntitiesByTypeState","emptyEntitiesByTypeState","emptyState","getEmptyIdsByTypeState","emptyIdsByTypeState","idsState","getEmptyState","entities","ids","modelSchemaReader","getType","relationKey","getRelationKeys","resolveRelationKey","typeOrKey","relationType","found","getRelationSchema","resolveRelationType","getRelationType","relationSchemas","resolveRelationCardinality","getRelationCardinality","resolveRelationReciprocalKey","getRelationReciprocalKey","resolveReciprocalCardinality","relationReciprocalKey","values","getRelationSchemaField","getEmptyEntityState","emptyRels","state","reltype","getEmptyRelationState","field","relationSchema","emptyIds","emptyEntities","entityTypeDne","entityType","relDne","indexLtZero","name","ActionUtils","actionTypes","isHandleable","action","isDerivable","DETACH","DELETE","ATTACH","isBatch","BATCH","isStateSetter","SET_STATE","Derivator","actionCreators","selectors","deriveAction","derivedActions","deriveDetachActions","original","derived","deriveAttachActions","deleteAction","cascade","deriveDeleteActions","cascadeNodes","getEntityTree","id","cascadeActions","cascadeAction","relation","detachableId","reciprocalKey","detach","attachableId","getEntity","attachableEntity","relAttachAction","attach","reciprocalIndex","entityDetachments","detachOccupant","relEntityDetachments","attachedIdsByRelationKey","getAllAttachedIds","detachActions","allDetachActions","attachedIds","map","attachedId","_this2","occupantId","getAttached","defaultNamespaced","actionType","namespaced","schemaReader","INVALID","CREATE","UPDATE","MOVE","MOVE_ATTACHED","SORT","SORT_ATTACHED","invalid","error","flattenActions","actions","accumulator","flattened","batch","options","messages","create","update","method","PATCH","move","src","dest","moveAttached","sort","compare","sortAttached","setState","actionUtils","makeActions","allSelectors","args","entity","getAttachedIds","attached","getIds","allAttachedIds","selectorSchema","nodes","recursivelyGetNodes","nestedSelectorSchema","makeSelectors","getPublicSelectors","reducer","derivator","singularReducer","singularAction","prevState","sortedIds","idA","idB","entitiesReducer","idsReducer","defaultEntitiesState","newEntity","filter","entitiesOfType","PUT","relationalData","relatedEntities","defaultIdsState","idsOfEntity","existingId","makeReducer"],"mappings":"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"}