function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelperLoose(o) {
  var i = 0;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) return function () {
      if (i >= o.length) return {
        done: true
      };
      return {
        done: false,
        value: o[i++]
      };
    };
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  i = o[Symbol.iterator]();
  return i.next.bind(i);
}

var Cardinalities;

(function (Cardinalities) {
  Cardinalities["ONE"] = "one";
  Cardinalities["MANY"] = "many";
})(Cardinalities || (Cardinalities = {}));

var UpdateActionMethod;

(function (UpdateActionMethod) {
  UpdateActionMethod["PUT"] = "put";
  UpdateActionMethod["PATCH"] = "patch";
})(UpdateActionMethod || (UpdateActionMethod = {}));

var arrayPut = function arrayPut(item, array, index) {
  if (!array) {
    return [item];
  }

  var newArray = [].concat(array); // must check against undefined because index might === 0

  index === undefined ? newArray.push(item) : newArray.splice(index, 0, item);
  return newArray;
};
function arrayMove(arr, fromIndex, toIndex) {
  if (fromIndex < 0 || toIndex < 0) {
    return arr;
  } // if the fromIndex is greater than the highest index, then set it as the highest index


  fromIndex = fromIndex > arr.length - 1 ? arr.length - 1 : fromIndex;
  var newArray = [].concat(arr);
  var element = newArray[fromIndex];
  newArray.splice(fromIndex, 1);
  newArray.splice(toIndex, 0, element);
  return newArray;
}
var isObjectLiteral = function isObjectLiteral(v) {
  return typeof v === 'object' && v !== null && !Array.isArray(v) && typeof v !== 'function';
};

var validateSchema = function validateSchema(schema) {
  if (!isObjectLiteral(schema)) {
    throw new Error('schema must be an object literal');
  }

  Object.entries(schema).forEach(function (_ref) {
    var type = _ref[0],
        entitySchema = _ref[1];

    if (!isObjectLiteral(entitySchema)) {
      throw new Error("schema of type \"" + type + "\" must be an object literal");
    }

    Object.entries(entitySchema).forEach(function (_ref2) {
      var rel = _ref2[0],
          relSchema = _ref2[1];

      if (!isObjectLiteral(relSchema)) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" must be an object literal");
      }

      if (!relSchema.hasOwnProperty('type')) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" is missing \"type\" attribute");
      }

      if (!schema.hasOwnProperty(relSchema.type)) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" relates to type \"" + relSchema.type + "\", but type \"" + relSchema.type + "\" does not have an entity schema of its own");
      }

      if (!relSchema.hasOwnProperty('cardinality')) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" is missing \"cardinality\" attribute");
      }

      if (relSchema.cardinality !== Cardinalities.MANY && relSchema.cardinality !== Cardinalities.ONE) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" cardinality must be either \"" + Cardinalities.ONE + "\" or \"" + Cardinalities.MANY + "\"");
      }

      if (!relSchema.hasOwnProperty('reciprocal')) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" is missing \"reciprocal\" attribute");
      }

      if (!schema[relSchema.type][relSchema.reciprocal]) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" has a reciprocal of \"" + relSchema.reciprocal + "\" on type \"" + relSchema.type + "\", but \"" + relSchema.type + "\" does not have a relation \"" + relSchema.reciprocal + "\"");
      }

      if (schema[relSchema.type][relSchema.reciprocal] && schema[relSchema.type][relSchema.reciprocal].reciprocal !== rel) {
        throw new Error("schema of type \"" + type + "\" relation \"" + rel + "\" has a reciprocal of \"" + relSchema.reciprocal + "\" on type \"" + relSchema.type + "\", but \"" + relSchema.reciprocal + "\" does not point back to \"" + rel + "\"");
      }
    });
  });
}; // returns type data clean of that type's rel keys
// does not clean out keys that are rel type names

var cleanData = function cleanData(data, schema, type) {
  return typeof data === 'object' ? Object.keys(data).reduce(function (cleanData, key) {
    if (!schema.type(type).hasRelationKey(key)) {
      cleanData[key] = data[key];
    }

    return cleanData;
  }, {}) : {};
};

var ModelSchemaReader = /*#__PURE__*/function () {
  function ModelSchemaReader(schema) {
    var _this = this;

    validateSchema(schema);
    this.schema = schema;
    this.entitySchemaReaders = Object.entries(schema).reduce(function (entitySchemaReaders, _ref) {
      var type = _ref[0],
          entitySchema = _ref[1];
      entitySchemaReaders[type] = new EntitySchemaReader(type, entitySchema, _this);
      return entitySchemaReaders;
    }, {});
  }

  var _proto = ModelSchemaReader.prototype;

  _proto.typeExists = function typeExists(type) {
    return this.getEntities().includes(type);
  };

  _proto.type = function type(_type) {
    return this.entitySchemaReaders[_type];
  };

  _proto.getEntities = function getEntities() {
    return Object.keys(this.schema);
  };

  _proto.getEmptyEntitiesByTypeState = function getEmptyEntitiesByTypeState() {
    if (!this.emptyEntitiesByTypeState) {
      this.emptyEntitiesByTypeState = this.getEntities().reduce(function (emptyState, type) {
        emptyState[type] = {};
        return emptyState;
      }, {});
    }

    return this.emptyEntitiesByTypeState;
  };

  _proto.getEmptyIdsByTypeState = function getEmptyIdsByTypeState() {
    if (!this.emptyIdsByTypeState) {
      this.emptyIdsByTypeState = this.getEntities().reduce(function (idsState, type) {
        idsState[type] = [];
        return idsState;
      }, {});
    }

    return this.emptyIdsByTypeState;
  };

  _proto.getEmptyState = function getEmptyState() {
    if (!this.emptyState) {
      this.emptyState = {
        entities: this.getEmptyEntitiesByTypeState(),
        ids: this.getEmptyIdsByTypeState()
      };
    }

    return this.emptyState;
  };

  return ModelSchemaReader;
}();
var EntitySchemaReader = /*#__PURE__*/function () {
  function EntitySchemaReader(type, schema, modelSchemaReader) {
    this.type = type;
    this.schema = schema;
    this.modelSchemaReader = modelSchemaReader;
  }

  var _proto2 = EntitySchemaReader.prototype;

  _proto2.getType = function getType() {
    return this.type;
  };

  _proto2.hasRelationKey = function hasRelationKey(relationKey) {
    return this.getRelationKeys().includes(relationKey);
  };

  _proto2.resolveRelationKey = function resolveRelationKey(typeOrKey) {
    var hasRelationKey = this.hasRelationKey(typeOrKey);

    if (hasRelationKey) {
      return typeOrKey;
    }

    var relationType = typeOrKey; // Iterate the relation schemas to find the one whose entity is the relationType.
    // It is possible that multiple relation schemas point to the same type, and consequently,
    // multiple keys would point to the type; in such a case we would return undefined.

    var found = undefined;

    for (var _iterator = _createForOfIteratorHelperLoose(this.getRelationKeys()), _step; !(_step = _iterator()).done;) {
      var relationKey = _step.value;
      var relationSchema = this.getRelationSchema(relationKey);

      if (relationSchema.type === relationType) {
        if (found) {
          // If a previously iterated relation schema has the given type
          // then it means multiple relation schemas point to the given type,
          // and a single key can be returned. For now, return undefined. Maybe
          // later implement returning an array of keys.
          return undefined;
        } // flag that a schema of the given type has been found


        found = relationKey;
      }
    }

    return found;
  };

  _proto2.resolveRelationType = function resolveRelationType(typeOrKey) {
    // if given a key, then just get the type by key
    var hasRelationKey = this.hasRelationKey(typeOrKey);

    if (hasRelationKey) {
      return this.getRelationType(typeOrKey);
    } // if given a type, then iterate each schema to see
    // whether a relation schema contains the type,
    // and if so the just return the type


    var relationType = typeOrKey;

    for (var _iterator2 = _createForOfIteratorHelperLoose(this.relationSchemas()), _step2; !(_step2 = _iterator2()).done;) {
      var relationSchema = _step2.value;

      if (relationSchema.type === relationType) {
        return relationType;
      }
    }

    return undefined;
  };

  _proto2.resolveRelationCardinality = function resolveRelationCardinality(typeOrKey) {
    var relationKey = this.resolveRelationKey(typeOrKey);

    if (!relationKey) {
      return undefined;
    }

    return this.getRelationCardinality(relationKey);
  };

  _proto2.resolveRelationReciprocalKey = function resolveRelationReciprocalKey(typeOrKey) {
    var relationKey = this.resolveRelationKey(typeOrKey);

    if (!relationKey) {
      return undefined;
    }

    return this.getRelationReciprocalKey(relationKey);
  };

  _proto2.resolveReciprocalCardinality = function resolveReciprocalCardinality(typeOrKey) {
    var relationKey = this.resolveRelationKey(typeOrKey);

    if (!relationKey) {
      return undefined;
    }

    var relationType = this.getRelationType(relationKey);
    var relationReciprocalKey = this.getRelationReciprocalKey(relationKey);

    if (!relationType || !relationReciprocalKey) {
      return undefined;
    }

    return this.modelSchemaReader.type(relationType).getRelationCardinality(relationReciprocalKey);
  };

  _proto2.getRelationKeys = function getRelationKeys() {
    return Object.keys(this.schema);
  };

  _proto2.relationSchemas = function relationSchemas() {
    return Object.values(this.schema);
  };

  _proto2.getRelationSchema = function getRelationSchema(relationKey) {
    return this.schema[relationKey];
  };

  _proto2.getRelationCardinality = function getRelationCardinality(relationKey) {
    return this.getRelationSchemaField(relationKey, 'cardinality');
  };

  _proto2.getRelationType = function getRelationType(relationKey) {
    return this.getRelationSchemaField(relationKey, 'type');
  };

  _proto2.getRelationReciprocalKey = function getRelationReciprocalKey(relationKey) {
    return this.getRelationSchemaField(relationKey, 'reciprocal');
  } //
  // state-getters
  //
  ;

  _proto2.getEmptyEntityState = function getEmptyEntityState(emptyRels) {
    if (!emptyRels) {
      return {};
    }

    return Object.entries(this.schema).reduce(function (state, _ref2) {
      var reltype = _ref2[0],
          relSchema = _ref2[1];

      if (relSchema.cardinality === Cardinalities.ONE) {
        state[reltype] = undefined;
      }

      if (relSchema.cardinality === Cardinalities.MANY) {
        state[reltype] = [];
      }

      return state;
    }, {});
  };

  _proto2.getEmptyRelationState = function getEmptyRelationState(relationKey) {
    var cardinality = this.getRelationCardinality(relationKey);
    return cardinality === Cardinalities.ONE ? undefined : [];
  };

  _proto2.getRelationSchemaField = function getRelationSchemaField(relationKey, field) {
    var relationSchema = this.getRelationSchema(relationKey);

    if (!relationSchema) {
      return undefined;
    }

    return relationSchema[field];
  };

  return EntitySchemaReader;
}();

var emptyIds = [];
var emptyEntities = {};
var makeSelectors = function makeSelectors(schema) {
  var getIds = function getIds(state, args) {
    var typeExists = schema.typeExists(args.type);

    if (!typeExists) {
      return emptyIds;
    }

    var ids = state.ids[args.type];
    return ids || emptyIds;
  };

  var getEntities = function getEntities(state, args) {
    var typeExists = schema.typeExists(args.type);

    if (!typeExists) {
      return emptyEntities;
    }

    var entities = state.entities[args.type];
    return entities || emptyEntities;
  };

  var getEntity = function getEntity(state, args) {
    var typeExists = schema.typeExists(args.type);

    if (!typeExists) {
      return undefined;
    }

    var entities = getEntities(state, args);
    return entities[args.id];
  };

  var getAttached = function getAttached(state, args) {
    var entitySchema = schema.type(args.type);

    if (!entitySchema) {
      return undefined;
    }

    var relationKey = entitySchema.resolveRelationKey(args.relation);

    if (!relationKey) {
      return undefined;
    }

    var entity = getEntity(state, args);

    if (!entity) {
      return undefined;
    }

    return entity[relationKey];
  };

  var getAttachedIds = function getAttachedIds(state, args) {
    var type = args.type,
        id = args.id,
        relation = args.relation;
    var relationKey = schema.type(type).resolveRelationKey(relation);

    if (!relationKey) {
      return [];
    }

    var attached = getAttached(state, {
      type: type,
      id: id,
      relation: relationKey
    });

    if (attached && typeof attached === 'string') {
      return [attached];
    }

    if (attached && Array.isArray(attached)) {
      return attached;
    }

    return [];
  };

  var getAllAttachedIds = function getAllAttachedIds(state, _ref) {
    var type = _ref.type,
        id = _ref.id;
    var entitySchema = schema.type(type);

    if (!entitySchema) {
      return {};
    }

    var allAttachedIds = {};
    var relationKeys = entitySchema.getRelationKeys();

    for (var _iterator = _createForOfIteratorHelperLoose(relationKeys), _step; !(_step = _iterator()).done;) {
      var relationKey = _step.value;
      var attachedIds = getAttachedIds(state, {
        type: type,
        id: id,
        relation: relationKey
      });

      if (attachedIds.length) {
        allAttachedIds[relationKey] = attachedIds;
      }
    }

    return allAttachedIds;
  };

  var getEntityTree = function getEntityTree(state, args) {
    var type = args.type,
        id = args.id,
        selectorSchema = args.schema;

    if (!schema.type(type)) {
      return [];
    }

    var rootEntity = getEntity(state, {
      type: type,
      id: id
    });

    if (!rootEntity) {
      return [];
    }

    var nodes = recursivelyGetNodes(state, type, id, selectorSchema);
    return Object.values(nodes);
  };

  var recursivelyGetNodes = function recursivelyGetNodes(state, type, id, selectorSchema, nodes) {
    if (nodes === void 0) {
      nodes = {};
    }

    var entity = getEntity(state, {
      type: type,
      id: id
    });

    if (!entity) {
      return nodes;
    }

    nodes[type + "." + id] = {
      id: id,
      type: type,
      entity: entity
    };

    if (typeof selectorSchema === 'function') {
      selectorSchema = selectorSchema();
    }

    for (var _i = 0, _Object$entries = Object.entries(selectorSchema); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _Object$entries[_i],
          relation = _Object$entries$_i[0],
          nestedSelectorSchema = _Object$entries$_i[1];
      var relationKey = schema.type(type).resolveRelationKey(relation);
      var relationType = schema.type(type).resolveRelationType(relation);

      if (relationKey && relationType) {
        var attachedIds = getAttachedIds(state, {
          type: type,
          id: id,
          relation: relationKey
        });

        for (var _iterator2 = _createForOfIteratorHelperLoose(attachedIds), _step2; !(_step2 = _iterator2()).done;) {
          var attachedId = _step2.value;
          recursivelyGetNodes(state, relationType, attachedId, nestedSelectorSchema, nodes);
        }
      }
    }

    return nodes;
  };

  return {
    getIds: getIds,
    getEntities: getEntities,
    getEntity: getEntity,
    getAttached: getAttached,
    getAllAttachedIds: getAllAttachedIds,
    getEntityTree: getEntityTree
  };
};
var getPublicSelectors = function getPublicSelectors(selectors) {
  var getIds = selectors.getIds,
      getEntities = selectors.getEntities,
      getEntity = selectors.getEntity;
  return {
    getIds: getIds,
    getEntities: getEntities,
    getEntity: getEntity
  };
};

var entityTypeDne = function entityTypeDne(entityType) {
  return "Entity-type \"" + entityType + "\" does not exist";
};
var relDne = function relDne(entityType, rel) {
  return "Entity \"" + entityType + "\" does not have a relation named \"" + rel + "\"";
};
var indexLtZero = function indexLtZero(name) {
  return name + " index is less than 0";
};

var makeActions = function makeActions(schema, namespaced) {
  var BATCH = namespaced('BATCH');
  var INVALID = namespaced('INVALID');
  var ATTACH = namespaced('ATTACH');
  var DETACH = namespaced('DETACH');
  var DELETE = namespaced('DELETE');
  var CREATE = namespaced('CREATE');
  var UPDATE = namespaced('UPDATE');
  var MOVE = namespaced('MOVE');
  var MOVE_ATTACHED = namespaced('MOVE_ATTACHED');
  var SORT = namespaced('SORT');
  var SORT_ATTACHED = namespaced('SORT_ATTACHED');
  var SET_STATE = namespaced('SET_STATE');

  var invalid = function invalid(action, error) {
    return {
      type: INVALID,
      error: error,
      action: action
    };
  };

  var batch = function batch() {
    for (var _len = arguments.length, actions = new Array(_len), _key = 0; _key < _len; _key++) {
      actions[_key] = arguments[_key];
    }

    var flattened = flattenActions(actions);
    return {
      type: BATCH,
      actions: flattened
    };
  };

  function flattenActions(actions) {
    var accumulator = [];
    actions.forEach(function (action) {
      if (action.type === BATCH) {
        var batchAction = action;
        var flattened = flattenActions(batchAction.actions);
        accumulator.push.apply(accumulator, flattened);
      } else {
        accumulator.push(action);
      }
    });
    return accumulator;
  }

  var attach = function attach(entityType, id, relation, attachableId, options) {
    if (options === void 0) {
      options = {};
    }

    var action = {
      type: ATTACH,
      entityType: entityType,
      id: id,
      relation: relation,
      attachableId: attachableId,
      index: options.index,
      reciprocalIndex: options.reciprocalIndex
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    if (!schema.type(entityType).resolveRelationKey(relation)) {
      return invalid(action, relDne(entityType, relation));
    }

    return action;
  };

  var detach = function detach(entityType, id, relation, detachableId) {
    var action = {
      type: DETACH,
      entityType: entityType,
      id: id,
      relation: relation,
      detachableId: detachableId
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    if (!schema.type(entityType).resolveRelationKey(relation)) {
      return invalid(action, relDne(entityType, relation));
    }

    return action;
  };

  var del = function del(entityType, id, cascade) {
    var action = {
      type: DELETE,
      entityType: entityType,
      id: id,
      cascade: cascade
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    return action;
  };

  var create = function create(entityType, id, data, index) {
    if (data === void 0) {
      data = {};
    }

    var action = {
      type: CREATE,
      entityType: entityType,
      id: id,
      data: data,
      index: index
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    } // data must be an object with only non-relational attributes


    action.data = cleanData(data, schema, entityType);
    return action;
  };

  var update = function update(entityType, id, data, options) {
    if (options === void 0) {
      options = {};
    }

    var action = {
      type: UPDATE,
      entityType: entityType,
      id: id,
      data: data,
      method: options.method || UpdateActionMethod.PATCH
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    } // data must be an object with only non-relational attributes


    action.data = cleanData(data, schema, entityType);
    return action;
  };

  var move = function move(entityType, src, dest) {
    var action = {
      type: MOVE,
      entityType: entityType,
      src: src,
      dest: dest
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    if (src < 0) {
      return invalid(action, indexLtZero('source'));
    }

    if (dest < 0) {
      return invalid(action, indexLtZero('destination'));
    }

    return action;
  };

  var moveAttached = function moveAttached(entityType, id, relation, src, dest) {
    var action = {
      type: MOVE_ATTACHED,
      entityType: entityType,
      id: id,
      relation: relation,
      src: src,
      dest: dest
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    if (!schema.type(entityType).resolveRelationKey(relation)) {
      return invalid(action, relDne(entityType, relation));
    }

    if (src < 0) {
      return invalid(action, indexLtZero('source'));
    }

    if (dest < 0) {
      return invalid(action, indexLtZero('destination'));
    }

    return action;
  };

  var sort = function sort(entityType, compare) {
    var action = {
      type: SORT,
      entityType: entityType,
      compare: compare
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    return action;
  };

  var sortAttached = function sortAttached(entityType, id, relation, compare) {
    var action = {
      type: SORT_ATTACHED,
      entityType: entityType,
      id: id,
      relation: relation,
      compare: compare
    };

    if (!schema.typeExists(entityType)) {
      return invalid(action, entityTypeDne(entityType));
    }

    if (!schema.type(entityType).resolveRelationKey(relation)) {
      return invalid(action, relDne(entityType, relation));
    }

    return action;
  };

  var setState = function setState(state) {
    return {
      type: SET_STATE,
      state: state
    };
  };

  var actionTypes = {
    BATCH: BATCH,
    INVALID: INVALID,
    ATTACH: ATTACH,
    DETACH: DETACH,
    DELETE: DELETE,
    CREATE: CREATE,
    UPDATE: UPDATE,
    MOVE: MOVE,
    MOVE_ATTACHED: MOVE_ATTACHED,
    SORT: SORT,
    SORT_ATTACHED: SORT_ATTACHED,
    SET_STATE: SET_STATE
  };
  var actionCreators = {
    batch: batch,
    attach: attach,
    detach: detach,
    "delete": del,
    create: create,
    update: update,
    move: move,
    moveAttached: moveAttached,
    sort: sort,
    sortAttached: sortAttached,
    setState: setState
  };
  var actionUtils = new ActionUtils(actionTypes);
  return {
    actionTypes: actionTypes,
    actionCreators: actionCreators,
    actionUtils: actionUtils
  };
};
var ActionUtils = /*#__PURE__*/function () {
  function ActionUtils(actionTypes) {
    this.actionTypes = actionTypes;
  }

  var _proto = ActionUtils.prototype;

  _proto.isHandleable = function isHandleable(action) {
    return Object.values(this.actionTypes).includes(action.type);
  };

  _proto.isDerivable = function isDerivable(action) {
    var _this$actionTypes = this.actionTypes,
        DETACH = _this$actionTypes.DETACH,
        DELETE = _this$actionTypes.DELETE,
        ATTACH = _this$actionTypes.ATTACH;
    return [DETACH, DELETE, ATTACH].includes(action.type);
  };

  _proto.isBatch = function isBatch(action) {
    return action.type === this.actionTypes.BATCH;
  };

  _proto.isStateSetter = function isStateSetter(action) {
    return action.type === this.actionTypes.SET_STATE;
  };

  return ActionUtils;
}();

var Derivator = /*#__PURE__*/function () {
  function Derivator(actionTypes, actionCreators, schema, selectors) {
    this.actionTypes = actionTypes;
    this.actionCreators = actionCreators;
    this.schema = schema;
    this.selectors = selectors;
  }

  var _proto = Derivator.prototype;

  _proto.deriveAction = function deriveAction(state, action) {
    var _this = this;

    if (action.type === this.actionTypes.DETACH) {
      var detachAction = action;
      var derivedActions = this.deriveDetachActions(detachAction);
      return {
        type: action.type,
        original: action,
        derived: derivedActions
      };
    }

    if (action.type === this.actionTypes.ATTACH) {
      var attachAction = action;

      var _derivedActions = this.deriveAttachActions(state, attachAction);

      return {
        type: action.type,
        original: action,
        derived: _derivedActions
      };
    }

    if (action.type === this.actionTypes.DELETE) {
      var deleteAction = action; // derive the actions that go along with deleting this entity

      var _derivedActions2 = [];

      if (!deleteAction.cascade) {
        _derivedActions2 = this.deriveDeleteActions(state, deleteAction);
      } // if cascading deletion, then derive all those actions


      if (deleteAction.cascade) {
        var _derivedActions3;

        var cascadeNodes = this.selectors.getEntityTree(state, {
          type: deleteAction.entityType,
          id: deleteAction.id,
          schema: deleteAction.cascade
        });
        var cascadeActions = [];
        cascadeNodes.forEach(function (_ref) {
          var id = _ref.id,
              type = _ref.type;

          var cascadeAction = _this.actionCreators["delete"](type, id);

          if (cascadeAction.type === _this.actionTypes.DELETE) {
            var cascadeDeleteAction = cascadeAction;
            cascadeActions.push.apply(cascadeActions, _this.deriveDeleteActions(state, cascadeDeleteAction));
          }
        });

        (_derivedActions3 = _derivedActions2).push.apply(_derivedActions3, cascadeActions);
      }

      return {
        type: action.type,
        original: action,
        derived: _derivedActions2
      };
    }

    return action;
  };

  _proto.deriveDetachActions = function deriveDetachActions(action) {
    var entityType = action.entityType,
        id = action.id,
        relation = action.relation,
        detachableId = action.detachableId;
    var schema = this.schema.type(entityType);
    var relationType = schema.resolveRelationType(relation);
    var reciprocalKey = schema.resolveRelationReciprocalKey(relation);

    if (!relationType || !reciprocalKey) {
      return [action];
    }

    var reciprocalAction = this.actionCreators.detach(relationType, detachableId, reciprocalKey, id);
    return [action, reciprocalAction];
  };

  _proto.deriveAttachActions = function deriveAttachActions(state, action) {
    var entityType = action.entityType,
        id = action.id,
        relation = action.relation,
        attachableId = action.attachableId;
    var schema = this.schema.type(entityType);
    var relationType = schema.resolveRelationType(relation);

    if (!relationType) {
      return [];
    } // check existence of entity


    var entity = this.selectors.getEntity(state, {
      type: entityType,
      id: id
    });

    if (!entity) {
      return [];
    } // check existence of attachable entity


    var attachableEntity = this.selectors.getEntity(state, {
      type: relationType,
      id: attachableId
    });
    var reciprocalKey = schema.resolveRelationReciprocalKey(relation);

    if (!attachableEntity || !reciprocalKey) {
      return [];
    } //
    // make the attach-action
    //


    var relAttachAction = this.actionCreators.attach(relationType, attachableId, reciprocalKey, id, {
      index: action.reciprocalIndex,
      reciprocalIndex: action.index
    }); //
    // make the detach-actions for the occupant entities
    //

    var entityDetachments = this.detachOccupant(state, entityType, id, relation);
    var relEntityDetachments = this.detachOccupant(state, relationType, attachableId, reciprocalKey);
    return [action, relAttachAction].concat(entityDetachments, relEntityDetachments);
  };

  _proto.deriveDeleteActions = function deriveDeleteActions(state, action) {
    var _this2 = this;

    var entityType = action.entityType,
        id = action.id;
    var entitySchema = this.schema.type(entityType);

    if (!entitySchema) {
      return [];
    } // get all attached entities


    var attachedIdsByRelationKey = this.selectors.getAllAttachedIds(state, {
      type: entityType,
      id: id
    }); // derive detachment actions

    var detachActions = Object.entries(attachedIdsByRelationKey).reduce(function (allDetachActions, _ref2) {
      var relationKey = _ref2[0],
          attachedIds = _ref2[1];
      var relationType = entitySchema.resolveRelationType(relationKey);

      if (!relationType) {
        return allDetachActions;
      }

      var reciprocalKey = entitySchema.resolveRelationReciprocalKey(relationKey);

      if (!reciprocalKey) {
        return allDetachActions;
      }

      var detachActions = attachedIds.map(function (attachedId) {
        return _this2.actionCreators.detach(relationType, attachedId, reciprocalKey, id);
      });
      allDetachActions.push.apply(allDetachActions, detachActions);
      return allDetachActions;
    }, []);
    return [action].concat(detachActions);
  };

  _proto.detachOccupant = function detachOccupant(state, entityType, id, relation) {
    var schema = this.schema.type(entityType);
    var relationType = schema.resolveRelationType(relation);
    var relationReciprocalKey = schema.resolveRelationReciprocalKey(relation);
    var cardinality = schema.resolveRelationCardinality(relation);

    if (!relationType || !relationReciprocalKey || cardinality === Cardinalities.MANY) {
      return [];
    }

    var occupantId = this.selectors.getAttached(state, {
      type: entityType,
      id: id,
      relation: relation
    });

    if (!occupantId) {
      return [];
    }

    return [this.actionCreators.detach(entityType, id, relationType, occupantId), this.actionCreators.detach(relationType, occupantId, relationReciprocalKey, id)];
  };

  return Derivator;
}();

var makeReducer = function makeReducer(schema, derivator, actionTypes, actionUtils) {
  var rootReducer = function rootReducer(state, action) {
    if (state === void 0) {
      state = schema.getEmptyState();
    }

    // if not handleable, then return state without changes
    if (!actionUtils.isHandleable(action)) {
      return state;
    }

    if (actionUtils.isStateSetter(action)) {
      if (action.type === actionTypes.SET_STATE) {
        return action.state;
      }
    }

    if (actionUtils.isBatch(action)) {
      // with a batch action, reduce iteratively
      var batchAction = action;
      return batchAction.actions.reduce(function (prevState, action) {
        return singularReducer(prevState, action);
      }, state);
    } else {
      // with a singular action, reduce once
      return singularReducer(state, action);
    }
  };

  function singularReducer(state, action) {
    var singularAction = action;
    var actions;

    if (actionUtils.isDerivable(singularAction)) {
      var derivedAction = derivator.deriveAction(state, singularAction);
      actions = derivedAction.derived;
    } else {
      actions = [singularAction];
    } // reduce [action]


    return actions.reduce(function (prevState, action) {
      // sort has to be handled here because it needs both slices
      if (action.type === actionTypes.SORT) {
        var _extends2;

        var entityType = action.entityType,
            compare = action.compare;
        var ids = prevState.ids[entityType];
        var entities = prevState.entities[entityType];
        var sortedIds = [].concat(ids).sort(function (idA, idB) {
          var entityA = entities[idA];
          var entityB = entities[idB]; // comparison error will need to be handled in the future
          // ...

          return compare(entityA, entityB);
        });
        return {
          entities: prevState.entities,
          ids: _extends({}, prevState.ids, (_extends2 = {}, _extends2[entityType] = sortedIds, _extends2))
        };
      } // all other actions handled here


      return {
        entities: entitiesReducer(prevState.entities, action),
        ids: idsReducer(prevState.ids, action)
      };
    }, state);
  }

  var defaultEntitiesState = schema.getEmptyEntitiesByTypeState();

  function entitiesReducer(state, action) {
    if (state === void 0) {
      state = defaultEntitiesState;
    }

    if (action.type === actionTypes.INVALID) {
      return state;
    }

    if (!schema.typeExists(action.entityType)) {
      return state; // if no such entityType, then no change
    }

    if (action.type === actionTypes.DETACH) {
      var _extends5, _extends6;

      var entityType = action.entityType,
          id = action.id,
          detachableId = action.detachableId,
          relation = action.relation;
      var entity = state[entityType][id];

      if (!entity) {
        return state; // if entity not found, then no change
      }

      var relationKey = schema.type(entityType).resolveRelationKey(relation);

      if (!relationKey) {
        return state; // if entity relation key not found, then no change
      }

      var newEntity = entity; // to contain the change immutably

      var cardinality = schema.type(entityType).resolveRelationCardinality(relation);

      if (cardinality === Cardinalities.ONE) {
        var _extends3;

        var attachedId = entity[relationKey];

        if (detachableId !== attachedId) {
          return state; // if detachableId is not the attached id, then no change
        } // detach it: set the relation value to undefined


        newEntity = _extends({}, entity, (_extends3 = {}, _extends3[relationKey] = undefined, _extends3));
      }

      if (cardinality === Cardinalities.MANY) {
        var _extends4;

        var attachedIds = entity[relationKey] || []; // detach it: filter out the detachableId

        newEntity = _extends({}, entity, (_extends4 = {}, _extends4[relationKey] = attachedIds.filter(function (attachedId) {
          return attachedId !== detachableId;
        }), _extends4));
      }

      return _extends({}, state, (_extends6 = {}, _extends6[entityType] = _extends({}, state[entityType], (_extends5 = {}, _extends5[id] = newEntity, _extends5)), _extends6));
    }

    if (action.type === actionTypes.ATTACH) {
      var _extends9, _extends10;

      var _entityType = action.entityType,
          _id = action.id,
          attachableId = action.attachableId,
          _relation = action.relation,
          index = action.index;
      var _entity = state[_entityType][_id];

      if (!_entity) {
        return state; // if entity not found, then no change
      }

      var _relationKey = schema.type(_entityType).resolveRelationKey(_relation);

      if (!_relationKey) {
        return state; // if entity relation key not found, then no change
      }

      var _newEntity = _entity; // to contain the change immutably

      var _cardinality = schema.type(_entityType).resolveRelationCardinality(_relation);

      if (_cardinality === Cardinalities.ONE) {
        var _extends7;

        _newEntity = _extends({}, _newEntity, (_extends7 = {}, _extends7[_relationKey] = attachableId, _extends7));
      }

      if (_cardinality === Cardinalities.MANY) {
        if (!_entity[_relationKey] || !_entity[_relationKey].includes(attachableId)) {
          var _extends8;

          _newEntity = _extends({}, _newEntity, (_extends8 = {}, _extends8[_relationKey] = arrayPut(attachableId, _newEntity[_relationKey], index), _extends8));
        }
      }

      return _extends({}, state, (_extends10 = {}, _extends10[_entityType] = _extends({}, state[_entityType], (_extends9 = {}, _extends9[_id] = _newEntity, _extends9)), _extends10));
    }

    if (action.type === actionTypes.DELETE) {
      var _extends11;

      var _entityType2 = action.entityType,
          _id2 = action.id;
      var _entity2 = state[_entityType2][_id2];

      if (!_entity2) {
        return state; // if entity not found, then no change
      }

      var entitiesOfType = _extends({}, state[_entityType2]);

      delete entitiesOfType[_id2];
      return _extends({}, state, (_extends11 = {}, _extends11[_entityType2] = entitiesOfType, _extends11));
    }

    if (action.type === actionTypes.CREATE) {
      var _extends12, _extends13;

      var _entityType3 = action.entityType,
          _id3 = action.id,
          data = action.data;
      var _entity3 = state[_entityType3][_id3];

      if (_entity3) {
        return state; // if entity exists, then no change
      }

      return _extends({}, state, (_extends13 = {}, _extends13[_entityType3] = _extends({}, state[_entityType3], (_extends12 = {}, _extends12[_id3] = data || {}, _extends12)), _extends13));
    }

    if (action.type === actionTypes.UPDATE) {
      var _extends14, _extends15;

      var _entityType4 = action.entityType,
          _id4 = action.id,
          _data = action.data,
          method = action.method;
      var _entity4 = state[_entityType4][_id4];

      if (!_entity4) {
        return state; // if entity not found, then no change
      }

      var _newEntity2 = _extends({}, _entity4);

      if (method === UpdateActionMethod.PUT) {
        // extract the current relational data, so we have a copy of it and it won't get overwritten
        var relationKeys = schema.type(_entityType4).getRelationKeys();
        var relationalData = relationKeys.reduce(function (relationalData, relationKey) {
          if (_entity4[relationKey]) {
            relationalData[relationKey] = _entity4[relationKey];
          }

          return relationalData;
        }, {}); // replace the current entity with the update data and the relational data

        _newEntity2 = _extends({}, _data, {}, relationalData);
      }

      if (method === UpdateActionMethod.PATCH) {
        // merge the update data with the current data
        _newEntity2 = _extends({}, _entity4, {}, _data);
      }

      return _extends({}, state, (_extends15 = {}, _extends15[_entityType4] = _extends({}, state[_entityType4], (_extends14 = {}, _extends14[_id4] = _newEntity2, _extends14)), _extends15));
    }

    if (action.type === actionTypes.MOVE_ATTACHED) {
      var _extends16, _extends17, _extends18;

      var _entityType5 = action.entityType,
          _id5 = action.id,
          _relation2 = action.relation,
          src = action.src,
          dest = action.dest;
      var _entity5 = state[_entityType5][_id5];

      if (!_entity5) {
        return state; // if entity not found, then no change
      }

      var _relationKey2 = schema.type(_entityType5).resolveRelationKey(_relation2);

      if (!_relationKey2) {
        return state; // if entity relation key not found, then no change
      }

      var _cardinality2 = schema.type(_entityType5).resolveRelationCardinality(_relation2);

      if (_cardinality2 === Cardinalities.ONE) {
        return state; // if cardinality is one, then no change
      }

      var _attachedIds = _entity5[_relationKey2];

      if (!Array.isArray(_attachedIds)) {
        return state; // if attached ids is not an array, then no change
      }

      var _newEntity3 = _extends({}, _entity5, (_extends16 = {}, _extends16[_relationKey2] = arrayMove(_attachedIds, src, dest), _extends16));

      return _extends({}, state, (_extends18 = {}, _extends18[_entityType5] = _extends({}, state[_entityType5], (_extends17 = {}, _extends17[_id5] = _newEntity3, _extends17)), _extends18));
    }

    if (action.type === actionTypes.SORT_ATTACHED) {
      var _extends19, _extends20, _extends21;

      var _entityType6 = action.entityType,
          _id6 = action.id,
          _relation3 = action.relation,
          compare = action.compare;
      var _entity6 = state[_entityType6][_id6];

      if (!_entity6) {
        return state; // if entity not found, then no change
      }

      var _relationKey3 = schema.type(_entityType6).resolveRelationKey(_relation3);

      var relationType = schema.type(_entityType6).resolveRelationType(_relation3);

      if (!_relationKey3 || !relationType) {
        return state; // if entity relation key or relation type not found, then no change
      }

      var _cardinality3 = schema.type(_entityType6).resolveRelationCardinality(_relation3);

      if (_cardinality3 === Cardinalities.ONE) {
        return state; // if cardinality is one, then no change
      }

      var _attachedIds2 = _entity6[_relationKey3];

      if (!Array.isArray(_attachedIds2)) {
        return state; // if attached ids is not an array, then no change
      }

      var relatedEntities = state[relationType];
      var sortedIds = [].concat(_attachedIds2).sort(function (idA, idB) {
        var entityA = relatedEntities[idA];
        var entityB = relatedEntities[idB]; // comparison error will need to be handled in the future
        // ...

        return compare(entityA, entityB);
      });

      var _newEntity4 = _extends({}, _entity6, (_extends19 = {}, _extends19[_relationKey3] = sortedIds, _extends19));

      return _extends({}, state, (_extends21 = {}, _extends21[_entityType6] = _extends({}, state[_entityType6], (_extends20 = {}, _extends20[_id6] = _newEntity4, _extends20)), _extends21));
    }

    return state;
  }

  var defaultIdsState = schema.getEmptyIdsByTypeState();

  function idsReducer(state, action) {
    if (state === void 0) {
      state = defaultIdsState;
    }

    if (action.type === actionTypes.INVALID) {
      return state;
    }

    if (!schema.typeExists(action.entityType)) {
      return state; // if no such entityType, then no change
    }

    if (action.type === actionTypes.DELETE) {
      var _extends22;

      var entityType = action.entityType,
          id = action.id;
      var idsOfEntity = state[entityType].filter(function (existingId) {
        return existingId !== id;
      });
      return _extends({}, state, (_extends22 = {}, _extends22[entityType] = idsOfEntity, _extends22));
    }

    if (action.type === actionTypes.CREATE) {
      var _extends23;

      var _entityType7 = action.entityType,
          _id7 = action.id,
          index = action.index; // this O(n) operation can be improved if existence is checked
      // in an O(c) lookup against the entities slice from one level up,
      // and then set the existence boolean on the action

      if (state[_entityType7].includes(_id7)) {
        return state; // if entity exists, then no change
      }

      return _extends({}, state, (_extends23 = {}, _extends23[_entityType7] = arrayPut(_id7, state[_entityType7], index), _extends23));
    }

    if (action.type === actionTypes.MOVE) {
      var _extends24;

      var _entityType8 = action.entityType,
          src = action.src,
          dest = action.dest;
      return _extends({}, state, (_extends24 = {}, _extends24[_entityType8] = arrayMove(state[_entityType8], src, dest), _extends24));
    }

    return state;
  }

  return rootReducer;
};

var fromNormalizr = function fromNormalizr(data) {
  var entitiesByType = data.entities;
  var state = {
    entities: {},
    ids: {}
  };
  Object.entries(entitiesByType).forEach(function (_ref) {
    var type = _ref[0],
        entities = _ref[1];
    state.entities[type] = entities;
    state.ids[type] = Object.keys(entities);
  });
  return state;
};

var defaultNamespaced = function defaultNamespaced(actionType) {
  return "normalized/" + actionType;
};

var makeNormalizedSlice = function makeNormalizedSlice(schema, namespaced) {
  if (namespaced === void 0) {
    namespaced = defaultNamespaced;
  }

  var schemaReader = new ModelSchemaReader(schema);

  var _makeActions = makeActions(schemaReader, namespaced),
      actionTypes = _makeActions.actionTypes,
      actionCreators = _makeActions.actionCreators,
      actionUtils = _makeActions.actionUtils;

  var allSelectors = makeSelectors(schemaReader);
  var selectors = getPublicSelectors(allSelectors);
  var emptyState = schemaReader.getEmptyState();
  var derivator = new Derivator(actionTypes, actionCreators, schemaReader, allSelectors);
  var reducer = makeReducer(schemaReader, derivator, actionTypes, actionUtils);
  return {
    emptyState: emptyState,
    selectors: selectors,
    actionTypes: actionTypes,
    actionCreators: actionCreators,
    reducer: reducer
  };
};

export default makeNormalizedSlice;
export { Cardinalities, UpdateActionMethod, fromNormalizr };
//# sourceMappingURL=normalized-reducer.esm.js.map
